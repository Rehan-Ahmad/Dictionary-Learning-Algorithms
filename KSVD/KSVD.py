# -*- coding: utf-8 -*-
"""
Created on Mon Jun 12 23:23:38 2017

@author: Rehan Ahmad

K-SVD Algorithm for Dictionary Learning.

 Data (nxk)      : Input Data / Signal.
 Dictionary (nxm): Dictionary as an input which will be updated by the algorithm.
                   Dictionary columns must be normalized by l2 norm. 
 CoefMat (mxk)   : Coefficient Matrix as an input generated by sparse algorithm
                   (OMP/BP/MP etc).
                   
 This implementation is taken from matlab code KSVD.m by:
 "The K-SVD: An Algorithm for Designing of Overcomplete Dictionaries for Sparse
  Representation", written by M. Aharon, M. Elad, and A.M. Bruckstein and 
  appeared in the IEEE Trans. On Signal Processing, Vol. 54, no. 11, 
  pp. 4311-4322, November 2006. 
  
"""
import numpy as np
from scipy.sparse.linalg import svds
from numpy.linalg import svd
from copy import deepcopy
import pdb

def KSVD(Data, Dictionary, CoefMat):

    Dict = deepcopy(Dictionary)        
    CoefMatrix = deepcopy(CoefMat)    
    rPerm = np.random.permutation(Dict.shape[1])
    
    for j in rPerm: 
        # the data indices that uses the j'th dictionary element.
        relevantDataIndices = np.nonzero(CoefMatrix[j,:])[0]
        if (len(relevantDataIndices)<1):
            ErrorMat = Data-np.dot(Dict,CoefMatrix)
            ErrorNormVec = np.sum(ErrorMat**2, axis = 0)
            d,i = np.max(ErrorNormVec),np.argmax(ErrorNormVec)
            betterDictionaryElement = deepcopy(Data[:,i])
            betterDictionaryElement = betterDictionaryElement/np.sqrt(\
                np.dot(betterDictionaryElement.T,betterDictionaryElement))
            betterDictionaryElement = betterDictionaryElement*\
                np.sign(betterDictionaryElement[0])
            CoefMatrix[j,:] = np.zeros((CoefMatrix.shape[1],))
            Dict[:,j] = deepcopy(np.reshape(betterDictionaryElement,(-1,)))            
            return Dict,CoefMatrix
    
        tmpCoefMatrix = deepcopy(CoefMatrix[:,relevantDataIndices]) 
        # the coeffitients of the element we now improve are not relevant.
        tmpCoefMatrix[j,:] = np.zeros((tmpCoefMatrix.shape[1]))
        # vector of errors that we want to minimize with the new element
        errors = Data[:,relevantDataIndices] - np.dot(Dict,tmpCoefMatrix) 
        # the better dictionary element and the values of beta are found using svd.
        # This is because we would like to minimize || errors - beta*element ||_F^2. 
        # that is, to approximate the matrix 'errors' with a one-rank matrix. This
        # is done using the largest singular value.
        try:
            uu,ss,vv = svd(errors)
            betterDictionaryElement,singularValue,betaVector = uu[:,0],ss[0],vv[0,:]
        except: 
            print "Error has occured in svd...You are now in pdb mode"
            pdb.set_trace()
                
        CoefMatrix[j,relevantDataIndices] = np.dot(singularValue,betaVector)
        Dict[:,j] = deepcopy(np.reshape(betterDictionaryElement,(-1,)))
        
    return Dict, CoefMatrix
